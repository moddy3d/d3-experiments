<html>
    <head>
        <link href="../static/css/style.css" rel="stylesheet">
        <style>
            .node > rect.core {
                fill: rgba(240, 240, 240, 1.0);
                stroke: rgba(190, 190, 200, 0.5);
            }

            .node:hover > rect.core {
                stroke: rgba(190, 190, 200, 1.0);
                transition: all 100ms linear;
            }

            .unassigned {
                fill: rgba(255, 0, 0, 0.5);
            }
            
            .load {
                fill: rgba(0, 125, 255, 0.5);
            }
            
            .complete {
                fill: rgba(55, 255, 55, 0.5);
            }

            .connection {
                stroke: rgba(220, 210, 220, 1.0);
                stroke-width: 1px;
                fill: none;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <a href='../'>back</a>
            <div class='date'>tues feb 10 2015</div>
            <h1 class="title">farm</h1>
            <div class='lead'>distributed farm jobs emulation</div>
            <div id='description'>
                Farm systems are efficient when the work is well distributed across all available nodes.
                <br/>
                A simplified implementation of a de-centralized system is offered here where work is assigned
                to one node and distributed across the network via a 'gossip'-like protocol.
            </div>
        </div>
        <script src='../static/js/d3.min.js'></script>
        <script>

            var width = 960,
                height = 540,
                size = 80,
                offset = {x: 325, y: 200},
                spacing = 130,
                QUORUM_LIMIT = 0.5;
            
            // prepare
          
            var nodes = [
                {x: 0, y: spacing / 2},
                {x: spacing, y: 0},
                {x: spacing, y: spacing},
                {x: spacing * 2, y: 0},
                {x: spacing * 2, y: spacing},
                {x: spacing * 3, y: spacing / 2},
                {x: spacing * 3, y: -spacing / 2},
                {x: spacing * 3, y: 3 * spacing / 2},
                {x: spacing * 4, y: spacing / 2}
            ];

            nodes = nodes.map( function (node, i) {
                node.id = i;
                node.load = 0;
                node.complete = 0;
                node.quorum = {};
                node.connections = [];
                return node;
            });

            var connections = [];

            function connect(a, b) {
                a.connections.push(b);
                b.connections.push(a);
                connections.push([a, b]);
            }

            connect(nodes[0], nodes[1]);
            connect(nodes[0], nodes[2]);
            connect(nodes[1], nodes[2]);
            connect(nodes[1], nodes[3]);
            connect(nodes[2], nodes[4]);
            connect(nodes[3], nodes[4]);
            connect(nodes[3], nodes[5]);
            connect(nodes[4], nodes[5]);
            connect(nodes[3], nodes[6]);
            connect(nodes[4], nodes[7]);
            connect(nodes[5], nodes[8]);
            
            // enter

            var svg = d3.select("body > .container").insert("svg", "#description")
                .attr("width", width)
                .attr("height", height);

            var line = d3.svg.line()
                .x( function (d) { return d.x })
                .y( function (d) { return d.y })
                .interpolate("step");

            svg.selectAll(".connection")
                .data(connections)
                .enter()
                .append("path")
                    .classed("connection", true)
                    .attr("d", function (d) {
                        var source = {x: d[0].x + offset.x, y: d[0].y + offset.y},
                            target = {x: d[1].x + offset.x, y: d[1].y + offset.y};
                        return line([source, target]);
                    });

            svg.selectAll(".node")
                .data(nodes)
                .enter()
                .append("g")
                    .classed("node", true)
                    .attr("transform", function (d) {
                        return "translate(" + (d.x + offset.x) + "," + (d.y + offset.y) + ")";
                    });

            svg.selectAll(".node")
                .append("rect")
                    .classed("core", true)
                    .attr("width", size)
                    .attr("height", size)
                    .attr("x", -size / 2)
                    .attr("y", -size / 2)
                    .attr("rx", size / 18)
                    .attr("ry", size / 18);

            svg.selectAll(".node")
                .append("rect")
                    .classed("complete", true)
                    .attr("width", size / 9)
                    .attr("height", 0)
                    .attr("x", size / 8)
                    .attr("y", size / 2);
                    
            svg.selectAll(".node")
                .append("rect")
                    .classed("load", true)
                    .attr("width", size / 9)
                    .attr("height", 0)
                    .attr("x", -size / 4)
                    .attr("y", size / 2);

            // 400 units of work...

            var unassigned = 300,
                assigned = 0,
                complete = 0;

            svg.selectAll("#unassigned-work")
                .data([unassigned])
                .enter()
                .append("rect")
                    .attr("id", "unassigned-work")
                    .classed("unassigned", true)
                    .attr("width", size / 9)
                    .attr("height", function (d) { return d })
                    .attr("x", offset.x - 250)
                    .attr("y", function (d) { return offset.y * 2 + d });
                    
            svg.selectAll("#assigned-work")
                .data([assigned])
                .enter()
                .append("rect")
                    .attr("id", "assigned-work")
                    .classed("load", true)
                    .attr("width", size / 9)
                    .attr("height", function (d) { return d })
                    .attr("x", offset.x - 200)
                    .attr("y", function (d) { return offset.y * 2 + d });
                    
            svg.selectAll("#complete-work")
                .data([complete])
                .enter()
                .append("rect")
                    .attr("id", "complete-work")
                    .classed("complete", true)
                    .attr("width", size / 9)
                    .attr("height", function (d) { return d })
                    .attr("x", offset.x - 150)
                    .attr("y", function (d) { return offset.y * 2 + d });
            
            // Schedule assignment to the leftmost node
            var assignment = setInterval(assign, 50);

            // gossip

            setInterval(function () { gossip(nodes[0]); }, 100);
            setInterval(function () { gossip(nodes[1]); }, 90);
            setInterval(function () { gossip(nodes[2]); }, 80);
            setInterval(function () { gossip(nodes[3]); }, 140);
            setInterval(function () { gossip(nodes[4]); }, 190);
            setInterval(function () { gossip(nodes[5]); }, 150);
            setInterval(function () { gossip(nodes[6]); }, 170);
            setInterval(function () { gossip(nodes[7]); }, 160);
            setInterval(function () { gossip(nodes[8]); }, 120);
                
            function gossip(node) {

                // Broadcast
                node.quorum[node.id] = {id: node.id, load: node.load, reference: node};

                // Discover
                node.connections.forEach( function (neighbor) {
                    for (var k in neighbor.quorum) {
                        var value = neighbor.quorum[k];
                        if (value.id !== node.id) 
                            node.quorum[value.id] = {id: value.id, load: value.load, reference: value.reference};
                    }
                });

                // Distribution
                var quorumCount = Object.keys(node.quorum).length;
                if (quorumCount > nodes.length * QUORUM_LIMIT) {
                    for (var k in node.quorum) {
                        if (node.load > node.quorum[k].load) {
                            if (node.load > 0) {
                                node.load -= 1;
                                node.quorum[k].reference.load += 1; 
                            }
                        }
                    }
                }
            }

            // compute
            nodes.forEach( function (node) {
                setInterval(function () { compute(node); }, 500);
            }); 

            function compute(node) {
                if (node.load > 0) {
                    node.load -= 1;
                    node.complete += 1;
                    assigned -= 1;
                    complete += 1;
                }
            };

            // update

            var rendering = setInterval(render, 50);

            function render() {
                var update = svg.selectAll(".node")
                    .data(nodes);

                update.selectAll(".node .complete")
                    .attr("y", function (d) { return size / 2 - d.complete * 1; })
                    .attr("height", function (d) { return d.complete * 1; });
                    
                update.selectAll(".node .load")
                    .attr("y", function (d) { return size / 2 - d.load * 1; })
                    .attr("height", function (d) { return d.load * 1; });

                svg.selectAll("#unassigned-work")
                    .data([unassigned])
                        .attr("height", function (d) { return d; })
                        .attr("y", function (d) { return offset.y * 2 - d; })
                        
                svg.selectAll("#assigned-work")
                    .data([assigned])
                    .transition()
                        .attr("height", function (d) { return d; })
                        .attr("y", function (d) { return offset.y * 2 - d; })
                        
                svg.selectAll("#complete-work")
                    .data([complete])
                    .transition()
                        .attr("height", function (d) { return d; })
                        .attr("y", function (d) { return offset.y * 2 - d; })
            };
            
            function assign() {
                if (unassigned === 0) {
                    clearInterval(assignment);
                }
                unassigned -= 1;
                assigned += 1;
                nodes[0].load += 1;
            };
            
        </script>
    </body>
</html>
